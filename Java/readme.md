# 자바

-------------

### JVM
> 어느기기, 어느운영체제 상에서도 실행될수 있다.

> 프로그램 메모리를 관리하고 최적화 한다.

> 자바 바이트 코드를 os에 맞게 해적해 주는 역할을 수행.

JVM이란 JAVA VIrtual Machine, 자바 가상 머신이다. JVM의 역할은 자바 애플리케이션 클래스 로더를 
통해 읽어들여 자바 API와 함께 실행하는 것이다. 그리고 JVM은 JAVA와 OS사이에서 중개자 역할을 
수행하여 **JAVA가 OS에 구애받지 않고 재사용**을 가능하게 해준다. 그리고 가장 중요한 메모리관리, Garbage collection을 수행한다. 그리고 JVM은 스택기반으로 동작한다.

**자바 프로그램 실행과정**
운영체제는 .class파일로 구성된 자바 바이트 코드를 바로 이해할수 없다 그래서 jvm이 자바의 바이트 코드를 os가 이해할수 있는 기계어로 해석해준다.

1. 프로그램이 실행되면 JVM은 OS로부터 이 프로그램이 필요로 하는 메모리를 할당받는다. JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.
2. 자바 컴파일러가 자바 소스코드를 읽어들여 자바 바이트 코드로 변환시킨다.
3. 클래스 로더를 통해 클래스 파일들을 JVM으로 로딩한다.
4. 로딩된 클래스 파일들은 JVM 실행엔진을 통해 해석된다.
5. 해석된 바이트 코드는 runtime data areas(JVM이 프로그램 수행을 위해 OS로 부터 할당받은 메모리 공간)에 배치되어 실질 적인 수행이 이루어진다.

--------------

### 가비지 컬렉션(Garbage Collection)

**가비지란?**
정리되지 않은메모리, 유효하지 않은 메모리 주소.(주소를 잃어버려서 사용할 수 없는 메모리가 정리되지 않는 메모리이다.

가비지 컬렉터는 메모리가 부족할때 가비지를 정리해주는 프로그램이다. 프로그램을 실행하다보면 가비지가 발생하는 데 이친구들은 사용되지 않으면서 자리를 차지하고 있게 된다. 그때 JVM의 가비지 컬렉터는 가비지를 다른 용도로 사용할 수있게 **메모리를 해제**시켜주는 프로그램이다.

가비지 컬렉터는 JVM이 메모리를 부여받고 열심히 프로그램을 실행하다가 메모리가 부족해지는 순간이 오면 OS에게 **추가로 메모리를 더 요청하게되는데 그때 가비지 컬렉터가 실행**된다.

-----------------

### 객체지향

**절차지향**은 기능중심. 순차적인 처리가 중요시.객체지향에 비해 빠르다. c언어가 대표적.

**객체지향**은 객체중심. 프로그램을 수많은 '객체'라는 기본단위로 나누고 이 객체들의 상호작용으로 서술하는 방식. 객체란 하나의 역할을 수행하는 메소드와 데이터의 묶음.

**객체지향 언어의 특징**
1. **상속** - 새로운 클래스가 기존의 클래스와 자료와 연산을 이용하게 해주는 것. 즉 쉽게말해 자식 클래스가 부모 클래스의 멤버를 물려받는 것이다.(자식객체가 부모객체의 추가적인 속성이나 메소드를 가진다.) 상위 계층을 **재사용**하여 **불필요한 코드 중복을 줄이고 유지보수에 용이**하다. 또한 객체의 **다형성을 구현**할 수 있다.
2. **추상화** - 객체들의 공통적인 **특징을 뽑아내는 것**. 구현하고자하는 객체드리 가진 **공통적인 데이터와 기능을 추상적으로 만드는것**. (반대개념으로는 구체화가 있다. 구체화는 상속을 통해 클래스를 구현, 확장하는 것)
3. **캡슐화** - 객체의 필드(속성), 메소드를 하나로 묶고, **실제 구현 내용을 외부에 감추는 것**. 자바 언어는 **캡슐화된 멤버들을 노출시킬 것인지 숨길 것인지를 결정하기 위해 접근 제어자(pulic, private 같은것)를 사용**한다. 외부 객체는 객체 내부의 구조를 얻지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다. 캡슐화의 이유는 외부의 잘못된 사용으로 객체가 손상되지 않게 하기 위함.
4. **다형성** - **같은 자료형에 여러가지 객체를 대입하여 다양한 결과를 얻어내는 성질**을 의미한다. 즉 같은 모양의 코드가 다른 행위를 하는 것이다. 하나의 타입으로 다양한 실행결과를 얻을 수 있고 객체를 부품화하여 유지보수를 용이하게 한다. **다형성의 개념을 나타내는 것은 오버로딩과 오버 라이딩**이 있다.
 - **오버 로딩**은 하나의 객체에서 **이름이 같은 메소드**를 여러개 정의하여 사용하는 것이다. 단 **메소드에 전달되는 인자의 종류와 개수는 달라야한다**.
 - **오버라이딩**은 상속을 받은 하위 객체가 상위 객체의 메소드를 새롭게 정의하고 그대로 덮어쓰고 사용하는 것을 말한다. 하위 객체의 메소드 이름과 인자값과 타입은 상위 객체의 메소드와 반드시 일치해야 된다. 원래 부모 클래스를 상속한 자식 클래스에서 부모의 메소드를 호출하면 부모 클래스에 정의된 메소드가 호출된다. 하지만 자식 클래스의 메소드가 부모 클래스의 메소드를 오버라이딩 한다면 자식 클래스에 정의된 메소드가 실행된다. 

-------------------------------

### 클래스

사용자 정의 자료형. 클래스란 객체를 정의하는 틀 또는 설계도 같은 의미로 사용.

### 인스턴스
자바에서 클래스를 사용하기 위해서는 우선 해당 클래스 타입의 객체를 선언해야된다. 이렇게 **클래스로부터 객체를 선언하는 과정을 클래스의 인스턴스 화**라고 한다. 이렇게 선언된 **클래스 타입의 객체를 인스턴스**라고 한다. 자바에서는 하나의 클래스로부터 여러개의 인스턴스를 생성할 수 있다. 이렇게 생성된 인스턴스는 독립된 메모리 공간에 저장된 자신만의 필드를 가질수 있다. 해당클래스의 모든 메소드는 해당 클래스에서 생성된 모든 인스턴스가 공유하게 된다.

### 메소드
특정한 작업을 수행하기 위한 명령문의 집합.

 - 접근 제어자 : 해당 메소드에 접근할 수 있는 범위를 명시. public, private, protected 등등 
 - 반환 타입
 - 메소드 이름
 - 파라미터 목록
 - 구현부
로 구성된다.

### static 
클래스에 고정된 멤버로 객체를 생성하지 않고 사용할 수 있는 필드와 메소드.

**클래스 변수, 인스턴스변수, 지역변수 차이**
1. 인스턴스 변수 : 객체를 생성해야만 사용, new 라는 키워드를 이용하여 만든다. 인스턴스 변수의 값을 사용하기 위해서는 인스턴스화가 필수적.
2. 클래스 변수 : 인스턴스변수 와 마찬가지로 클래스 내부에 위치 . **static** 을 붙여 주면 클래스 변수. 전역 변수라고 부르기도 한다. 굳이 객체를 생성하지않고 클래스명으로 접근가능하다. 
3. 지역변수 : 멤버 변수를 제외한 나머지 변수들 클래스 영역이아닌 다른 블럭({})에 존재하는 지역변수이다. 지역변수가 선언된 블록을 벗어나면 그 지역 변수는 사라진다. 

------------------------------------------------------
### 디자인 패턴

소프트웨어를 설계할때 특정 맥락에서 자주 발생하는 고질적인 문제들이 또 발생했을때 재사용을 할 수있는 훌륭한 해결책.

**디자인 패턴의 종류 3가지**
1. 생성패턴 : 객체 생성에 관련된 패턴. 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 	변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공한다.
2. 구조패턴 : 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴.
3. 행위패턴 : 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴. 한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하는지, 또 그렇게 하면서도 객체 사이의 결합도를 최소화하는 것에 중점을 둔다.

