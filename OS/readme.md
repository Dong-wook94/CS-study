
# 운영체제
**************

## System call
process 와 운영체제 간에 인터페이스를 제공. 커널에서만 사용할 수 있는 
instruction들을 사용자가 사용할 수 있게 해줌. 커널에 접근을 가능하게 한다.

------------------

## Process
프로그램 : 어떤 작업을 위해 실행할 수 있는 파일.

### 프로세스 : 실행중인 프로그램
```
* 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인개체)
* 운영체제로부터 시스템 자원을 할당받는 작업의 단위

* 할당받는 시스템 자원의 예
	- CPU 시간
    - 운영되기 위해 필요한 주소공간
    - Code, Data, Stack, Heap의 구조로 되어있는 독립된 메모리 영역
```

**프로세스는 실행중인 프로그램**(프로그램은 어떤 작업을 위해 실행할 수 있는 파일)으로 디스크로부터 메모리에 적재되어 CPU의할당을 받을 수 있는것을 말한다. 운영체제로부터 주소 공간, 파일, 메모리 등을 할당받으며 이것들을 
총칭하여 프로세스라고 한다. 구체적으로 살펴보면 프로세스는 함수의 매개변수, 복귀 주소와 로컬 
변수와 같은 임시 자료를 갖는 프로세스 스택과 전역 변수들을 수록하는 데이터 섹션을 포함한다. 
또한 프로세스는 프로세스 실행 중에 동적으로 할당되는 메모리인 힙을 포함한다. 



-------------------------------

## 프로세스 제어 블록(PCB)
 PCB는 특정 **프로세스에 대한 중요한 정보를 저장** 하고 있는 운영체제의 자료구조이다. 
운영체제는 
프로세스를 관리하기 위해 프로세스의 생성과 동시에 고유한 PCB를 생성한다. 프로세스 CPU를 
할당받아 작업을 처리하다가도 프로세스 전환이 발생하면 진행하던 작업을 저장하고 CPU를 변환해야 
하는데, 이때 작업의 진행 상황을 모두 PCB에 저장하게 된다. 그리고 다시 CPU를 할당받게 되면 PCB에 
저장되어있던 내용을 불러와 이전에 종료됐던 시점부터 다시 작업을 수행한다.

<img src="https://user-images.githubusercontent.com/36303777/56964310-e652dc80-6b95-11e9-8505-f79c3de5169f.png" width="300"></img>


--------------------------------

### PCB에 저장되는 정보
- 프로세스 식별자(Process ID. PID) : 프로세스 식별번호
- 프로세스 상태 : new, ready, running, waiting, terminated 등의 상태를 저장.
- 프로그램 카운터 : 프로세스가 다음에 실행할 명령어의 주소
- CPU 레지스터
- CPU 스케쥴링 정보 : 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등.
- 메모리 관리 정보 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함.
- 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록.
- accounting 정보 : 사용된 CPU 시간, 시간제한, 계정번호 등.

<hr>

## 프로세스 상태

- new : 프로세스 생성중
- running : 명령어들이 실행되고 있다.
- waiting : event를 기다림.
- ready : 프로세스가 프로세서에 할당되기를 기다리고 있는 상태.
- terminated : 프로세스의 실행이 종료됨.

-----------------------

## 프로세스 스케쥴링

- multiprogramming : CPU 사용률을 최대화
- time-sharing(시분할) : 프로세스를 빈번하게 바꾸어 가면서 실행 -> 사용자와 프로그램이 상호작용 
가능.
- 프로세스 스케쥴링 : 프로세스가 다음 실행할 프로세스를 선택.
- job 큐 : 프로세스가 시스템에 처음 들어와서 대기하는 큐. 시스템안의 모든 프로세스로 구성. 
주메모리에 존재한다.
- ready 큐 : CPU를 사용할 준비가된 프로세스들이 기다리는 큐. 연결리스트 형태로 저장. ready 큐의 
헤더는 리스트의 첫번째와 마지막 PCB를 가리키는 포인터를 포함한다.
- device 큐 : 특정 입출력 장치를 대기하는 프로세스들의 리스트. 각 디바이스는 자체 큐를 가진다.

---------------------------------

## 스케쥴러

운영체제는 스케쥴러를 통해 선택 절차(policy)에 따라 다양한 스케쥴링 큐들 사이에서 프로세스를 
선택한다.

- 장기 스케쥴러(job 스케쥴러) : 
	* 한번에 병행으로 사용할 수 있는 작업의 수 제한적.
	* 메모리와 디스크 사이의 스케쥴링을 할당.
	* ready 큐에 수용되지 못하는 작업은 디스크에 유지되는 job poo에 유지된다.
	* degree of Multiporgramming 제어. 메모리에 여러 프로그램이 올라가는지 제어한다. 
    * 장기 스케쥴러는 CPU와 I/O작업을 적절하게 하는 것이 좋다(노는곳 없이) CPU와 I/O작업을 병렬적으로 수행하면 성능이 올라간다.
- 단기 스케쥴러 (CPU 스케쥴러) : 
	* CPU와 메모리 사이의 스케쥴링을 담당한다.
	* ready 큐에서 다음에 CPU에 할당할 프로세스를 고른다.(프로세스에 CPU 할당)
	
- 프로세스의 타입
	* 입출력 중심 프로세스 : 연산보다는 입출력을 ㅁ낳이하는 프로세스
	* cpu 중심 프로세스 : 입출력 중심 프로세스보다 연산에 시간을 더 소요.
    
-------------------------------

## 문맥교환(Context switch)

실행중인 프로세스의 상태를 PCB에 보관하고 새로운 프로세스의 CPU에 적재한다. 문맥은 CPU 레지스터의 값, 프로세스 상태, 메모리 관리 정보 등을 포함한다. 

인터럽트가 발생하면 시스템은 인터럽트 처리가 끝난 후에 문맥을 복구할 수 있도록 현재 실행 중인 프로세스의 현재 문맥을 저장할 필요가 있다. 

문맥교환시간은 순수한 오버헤드 이다.

<hr>

## Unix/Linux 시스템에서의 프로세스 생성

- fork() : 새로운 프로세스 생성
- exec() : 자신의 메모리공간을 새로운 프로그램으로 교체.
- wait() : 부모는 wait() 시스템 콜을 통해 자식 프로세스가 끝나기를 기다린다.

----------------------------

## 스레드

스레드는 가장 작은 CPU 이용 기본단위. 

* 스레드의 구성
	- 스레드 ID
    - 프로그램 카운터
    - 레지스터 집합
    - 스택
* 스레드는 프로세스 내에서 각각 Stack만 따로 할당받고, Code, Data Heap영역은 공유한다.
* 스레드는 한프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소공간이나 자원들(힙 공간 등)을 같은 프로세스 내에 스레드끼리 공유하면서 실행된다.
* 같은 프로세스 안에 있는 여러 스레드들은 같은 힙공간을 공유한다. 반면에 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없다.
* 각각의 스레드는 별도의 레지스터와 스택을 갖고 있지만, 힙 메모리는 서로 읽고 쓸 수 있다.
* 한스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드도 그 변경 결과를 볼 수 있다.
* 스레드의 장점 
	- 응답성 : 하나의 프로세스가 긴작업을 수행하더라도 다른 스레드가 대신 일을 해줌으로써 프로그램의 수행이 계속된다. 이때문에 사용자에 대한 응답성이 증가된다.
    - 자원 공유 : 스레드는 프로세스의 자원들과 메모리를 공유하기때문에 자원 공유가 용이. 프로세스는 공유메모리와 메모리 전달기법을 통해 자원을 공유해야 되기 때문에 비교적 어렵다.
    - 경제성 : 스레드는 자신이 속한 프로세스의 자원들을 공유하기 때문에 스레드를 생성하고 문맥 교환하는 것이 비교적 경제적이다.
    - 확장성 : 다중 스레드의 이점. 병렬수행가능
    
---------------------

## Parallelism(병렬실행) vs Concurrency(병행실행)

* 병렬 실행 : 하나이상의 일을 동시에 수행할 수 있는 시스템.

* 병행 실행 : 여러개의 일이 실제로 동시에는 아니더라도 여러 개가 같이 진행되어 나가는것. (CPU 스케줄러는 시스템의 프로세스 사이를 빠르게 오가며 모든 프로세스를 진행시켜 마치 병렬 실행하는듯한 환상을 주도록 설계되었다. 이는 병렬실행이 아니라 병행 실행이다.)

-------------

## parallelism 종류

* 데이터 병렬실행 : 데이터를 n등분하여 처리 하여 병렬성을 높인다.
* task 병렬실행 : task 자체를 구분하여 병렬화.

----------------

## 프로세스 스케쥴링

* 스케쥴링의 대상이 되는 객체는 스레드이다.
* 스케쥴링은 CPU 이용률을 최대화 하기위해 필요하다.

------------

## CPU 스케쥴러

스케쥴링의 대상은 ready queue 에 있는 프로세스들이다.

**First Come First Served(선입 선처리 스케쥴링)** : CPU를 먼저 요청하는 프로세스가 CPU를 먼저 할당받는다.
- 비선점형 스케쥴링
- 소요시간이 긴 프로세스가 먼저 도달하여 효율성이 낮아질수 있다.

**Shortes-Job-Firs Scheduling (최단 작업 우선 스케쥴링)**: 다른 프로세스가 먼저 도착했어도 CPU burst time이 짧은 프로세스에게 선 할당.
- starvation 발생 가능 : 효율성을 추구하는 건 좋은데 특정 프로세스가 길다면 계속 할당받지 못할수 있다.
- 이또한 비선점형 스케쥴링

**Priority Scheduling(우선순위 스케쥴링)** : 우선순위가 가장 높은 프로세스에게 CPU를 할당하는 것.
- 선점형 스케쥴링 방식 : 더 높은 우선순위의 프로세스가 왔을때 실행중인 프로세스를 멈추고 CPu를 선점한다.
-  비선점형 스케쥴링 방식 : 더높은 우선순위의 프로세스가 왔을때 ready queue의 head에 넣는다.
- 기아현상 발생 가능
- 우선순위가 낮더라도 오래 기다리면 우선순위를 높이면됨(해결책)

**Round Robin** 
- 현대적인 CPU 스케줄링
- 각프로세스는 동일한 크기의 할당시간을 갖게된다.
- 기본적인 정책은 선입선출
- 할당시간이 지나면 프로세스는 선점당하고 ready queue의 제일 뒤에가서 줄을 선다.

---------------

## 프로세스 동기화

**생산자-소비자 문제**
여러개의 프로세스를 어떻게 동기화 할 것인가.

**Critical Section Problem**
Critical section 은 멀티 스레딩 상황에서 동일한 자원을 동시에 접근하는 작업을 실행하는 코드영역. 이때 프로세스들이 critical section을 함께 사용할수 있는 프로토콜을 설계하는 것.

**해결방안 세가지**
* 상호배제(mutual exclusion)
* 진행(progress) : critical section에서 실행중인 프로세스가 없고, 별도의 동작이 없는 프로세스들만 critical section 진입후보로서 참여될 수 있다.
* 한정된 대기(bounded waiting)

--------------------

## 뮤텍스 락과 세마포어

**뮤텍스 락**

임계구역에 들어갈때 락을 획득하고 임계구역을 빠져나올때 락을 반환해야한다.
단점 : 바쁜대기를 해야한다. 

**세마포어**
세마포 는 정수변수로서, 두개의 표준 원자적 연산 wait(), signal()로만 접근이 가능하다.
 - 카운팅 세마포 : 가용한 개수를 가진 자원에 대한 접근제어용으로 사용되며, 세마포는 그 가용한 자원의 개수로 초기화 된다. 자원을 사용하면 세마포가 감소, 방출하면 세마포가 증가한다.
 - 이진 세마포 : mutex라고도 부르며 이름 그대로 0과 1사이의 값만 가능하며, 다중 프로세스들 사이의 임계구역 문제를 해결하기 위해 사용한다.
 단점은 바쁜대기이다. 

### 두개의 차이점 
세마포어는 뮤텍스가 될 수 있지만 뮤텍스는 뮤텍스 세마포어 카운트가 1이면 뮤텍스이다(이진세마포어). 뮤텍스는 락을 소유한 스레드가 직접 해제한다. 세마포어는 외부에서 조정이 가능하고 일반적으로 세마포어는 프로세스 단위에서 접근하는 것을 관리한다. 뮤텍스는 스레드 단위에서 접근하는 것을 관리하기 위해 사용.

--------------

## 교착상태
세마포가 ready 큐를 가지고있고 둘이상의 프로세스가 임계구역 진입을 무한정 기다리고 있고, 임계구역에서 실행되는 프로세스는 진입 대기중인 프로세스가 실행 되어야만 빠져나올수 있는 상황.

#### 데드락의 발생조건
교착상태는 한 시스템 내에서 다음의 네가지 조건이 동시에 성립 할 때 발생한다. 따라서 아래의 4가지 조건중 하나라도 성립하지 않도록 만든다면 교착상태를 해결할 수 있다.
1. **상호배제(Mutual exclusion)** : 자원은 한번에 한 프로세스만이 사용할 수 있어야한다.
예방법 ) 상호배제 부정 :여러개의 프로세스가 공유자원을 사용할 수 있도록 한다.
2. **점유 대기(Hold and wait)** : 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다.
예방법 ) 점유대기 부정 : 프로세스가 실행되기 전 필요한 모든 자원을 할당한다.
3. **비선점(No preemption)** : 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다.
예방법) 비선점 부정 : 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고, 요구한 자원을 사용하기 위해 기다리게 한다.
4. **순환 대기(Circular wait)** : 프로세스의 집합 {P0,P1,...,Pn에서 P0는 P1이 점유한 자원을 대기하고 P1은 P2가 점유한 자원을 대기하고 P2...Pn-1은 Pn이 점유한 자원을 대기하며 Pn은 P0가 점유한 자원을 요구해야 한다.
예방법 ) 순환대기 부정 : 자원에 고유한 번호를 할당하고, 번호 순서대로 자원을 요구하도록 한다.

#### 데드락 처리방법
1. **교착상태 예방 및 회피** : 교착상태가 되지 않도록 보장하기 위하여 교착상태를 예방하거나 회피하는 프로토콜을 이용하는 방법
2. **교착상태 탐지 및 회복** :교착상태가 되도록 허용한 다음에 회복시키는 방법(교착상태로부터 회복이란 교착상태를 일으킨 프로세스를 종료하거나, 할당된 자원을 해제함으로써 회복하는 거을 의미한다.)
3. **교착 상태 무시** : 대부분의 시스템은 교착상태가 잘 발생하지 않으며, 교착상태 예방, 회피, 탐지, 복구하는 것은 비용이 많이 든다.

--------------------

### 페이지 교체

#### 요구 페이징(Demand Paging)
프로그램 실행 시작시 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신 **초기에 필요한 것들만 적재하는 전략을 요구페이징**이라하며, 가상 메모리 시스템에서 많이 사용된다. 그리고 가상 메모리는 대개 페이지로 관리된다. 요구 페이징을 사용하는 가상 메모리에서 실행과정에서 필요해질 때 페이지들이 적재된다. 한번도 접근되지 않은 페이지는 물리메모리에 적재되지 않는다.

#### 페이지 교체
요구페이징에서 언급된대로 프로그램 실행시에 모든 항목이 물리메모리에 올라오지 않기 때문에, 프로세스의 동작에 필요한 페이지를 요청하는 과정에서 page fault(페이지 부재)가 발생하게 되면, 원하는 페이지를 보조저장장치에서 가져오게 된다. 하지만 물리 메모리가 모두 사용중인 상황이라면, 페이지 교체가 이뤄져야 한다.

**페이지 교체 방법**
* FIFO : 선입선출(벨라디의 모순이 발생할수있다. 벨라디의 모순은 페이지를 저장할수있는 페이지 프레임의 개수를 늘려도 되려 페이지 부재가 더발생하는 모순이 존재.)
* LRU : 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체
* LFU : 참조횟수가 가장 적은 페이지를 교체
* MFU : 참조횟수가 가장 작은 페이지가 최근에 메모리에 올라왔고, 앞으로 계속 사용될 것이라는 가정에 기반.
