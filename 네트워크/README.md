# 네트워크

## HTTP의 GET과 POST 비교
둘 다 Http 프로토콜을 이용해서 서버에 무엇인가를 요청할 때 사용하는 방식이다.
GET, POST 방식의 request는 서버로 본인이 가지고 있는 data를 전달하기 위해서 사용합니다.


### GET
- URL에 변수(데이터)를 포함시켜 요청한다.
- 데이터를 Header(헤더)에 포함하여 전송한다.
- URL에 데이터가 노출되어 보안에 취약하다.
- 전송하는 길이에 제한이 있다.
- 캐싱할 수 있다.(캐싱이란 한번 접근후에 또 요청할시 빠르게 접근하기위해 레지스터에 데이터를 저장시켜 놓는것.)
- GET 방식은 간단한 데이터를 URL에 넣도록 설계된 방식으로 데이터를 보내는 양에 한계가 있습니다.
- URL의 길이가 정해져 있기 때문에 '많은 양의 정보를 전달 할 수 없다'
- URL 형식에 맞지 않는 파라미터 이름이나 값은 인코딩되어 전달해야 합니다. 
- 길이가 너무 길어 생기는 초과데이터는 절단됩니다. 

### POST
- URL에 변수(데이터)를 노출하지 않고 요청한다.
- 데이터를 Body(바디)에 포함시킨다.
- URL에 데이터가 노출되지 않아서 기본 보안은 되어있다.
- 캐싱할 수 없다.
- GET방식은 URL에 데이터를 붙여서 전송하는 반면에 POST방식은 BODY에 데이터를 넣어서 전송합니다. 
- 헤더필드 중 Body의 데이터를 설명하는 Content-Type이라는 헤더 필드가 들어가고 어떠한 데이터 타입인지를 명시해주어야 합니다. 
- 데이터를 Body에 포함시키는 이점 때문에 메시지 길이의 제한이 없다.
- 메시지 길이의 제한은 없지만 최대 요청을 받는 시간인 Time Out이 존재하므로 클라이언트에서 페이지를 요청하고 기다리는 시간이 존재한다.

---------------------------------------------------
## TCP와 UDP의 차이점

TCP/IP에는 TCP와 UDP가 존재하는데 TCP는 신뢰성이 있는 연결을 지향하며. UDP는 빠른 전송을 지향하는 것에서 차이점이 있다. UDP는 일방적인 데이터 전송을 하는 반면, TCP는 데이터 하나라도 놓치지 않고 완벽히 보내는 것이 목표이기 때문에 방향성이 완전 다르다.

그래서 UDP는 알고리즘이 간단한 반면, TCP는 연결부터 끊는 과정까지 상대적으로 복잡하다.

## TCP의 특징
* 인터넷 상에서 데이터를 메세지의 형태(세그먼트라는 블록 단위)로 보내기 위해 IP와 함께 사용하는 프로토콜이다.
    - TCP와 IP를 함께 사용하는데, IP가 데이터의 배달을 처리한다면 TCP는 패킷을 추적 및 관리한다.
* 연결형 서비스로 가상 회선방식을 제공한다.
    - 3-way handshaking 과정을 통해 연결을 설정하고, 4-way handshaking을 통해 연결을 해제한다.
* 흐름제어 및 혼잡제어를 제공한다.
    - 흐름제어 
        - 데이터를 송신하는 곳과 수신하는 곳의 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지하는 것.
        - 송신하는 곳에서 감당이 안되게 많은 데이터를 빠르게 보내 수신하는 곳에서 문제가 일어나는 것을 막는다.
    - 혼잡제어
        - 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것.
        - 정보의 소통량이 과다하면 패킷을 조금만 전송하여 혼잡 붕괴현상이 일어나는 것을 막는다.
* 높은 신뢰성을 보장한다.
* UDP보다 속도가 느리다.
* 전송이 양방향으로 동시에 일어날 수 있다.
* 각 연결이 정확히 2개의 종단점을 가지고 있다.
* 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다.
* 연속성보다 신뢰성있는 전송이 중요할 때에 사용된다.

## TCP의 3-way handshake
TCP 통신을 이용하여 데이터를 전송하기위해 네트워크 '연결을 설정하는 과정'
* 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달이 시작하기 전에 한 쪽이 다른 쪽이 준비되었다는 것을 알 수 있도록 한다.
    - 즉, TCP/IP 프로토콜을 이용해서 통신을 하는 응용 프로그램이 데이터를 전송하기전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.

과정
![image](https://user-images.githubusercontent.com/36303777/66185799-7d7b0d80-e6bb-11e9-8738-e6f8f23c48c9.png)
1) 클라이언트는 서버에 접속을 요청하는 SYN(a) 패킷을 보낸다.
2) 서버는 클라이언트의 요청인 SYN(a)를 받고 클라이언트에게 요청을 수락한다는 ACK(a+1)와 SYN(b)이 설정된 패킷을 발송한다.
3) 클라이언트는 서버의 수락 응답인 ACK(a+1)와 SYN(b) 패킷을 받고 ACK(b+1)를 서버로 보내면 연결이 성립된다.
## TCP의 4-way handshake
TCP의 '연결을 해제하는 과정'
![image](https://user-images.githubusercontent.com/36303777/66186068-3ccfc400-e6bc-11e9-87b5-45c87c271f76.png)
1) 클라이언 트가 연결을 종료하겠다는 **FIN플래그**를 전송한다.
2) 서버는 클라이언트의 요청(**FIN**)을 받고 확인 메시지로 **ACK**를 보낸다. 그리고나서는 데이터를 모두 보낼 때 가지 잠깐 **TIME_OUT** 된다.
3) 데이터를 모두 보내고 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 **FIN** 플래그를 전송한다.
4) 클라이언트는 **FIN메시지**를 확인했다는 **메시지(ACK)**를 보낸다.
5) 클라이언트의 **ACK 메시지**를 받은 서버는 소켓 **연결을 close** 한다.
6) 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을것을 대비해 일정 시간 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거친다.(**TIME_WAIT**)

## SYN Packet & ACK Packet
* SYN : synchronize sequence number
* ACK : acknowledgement

TCP Header에는 Code Bit(Flag bit)라는 부분이 존재한다. 이 부분은 6bit로 이루어져 있으며 각각 한 bit들이 의미를 갖고 있다. Urg-Ack-Psh-Rst-Syn-Fin 순서로 되어있으며 해당 위치의 비트가 1이면 해당 패킷이 어떠한 내용을 담고 있는 패킷인지를 나타낸다. SYN 패킷일 경우엘 000010이 되고 ACK패킷일 경우에는 010000이 되는것이다.

## randomized sequence number 사용이유
처음 클라이언트에서 SYN패킷을 보낼대 Sequence Number에는 랜덤한 숫자가 담겨진다. 초기 Sequence number를 ISN이라고한다. ISN이 0부터 시작하지않고 난수를 생성해서 number를 설정하는 이유는 Connection을 맺을때 사용하는 포트는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용된다. 따라서 두 통신 호스타가 과거에 사용된 포트번호 쌍을 사용하는 가능성이 존재한다. 서버 측에서는 패킷의 SYN을 보고 패킷을 구분하게 되는데 난수가 아닌 순차적인 number가 전송된다면 이전의 connection으로부터 오는 패킷으로 인식할 수 있다. 이러한 문제가 발생할 가능성을 줄이기 위해서 난수로 ISN을 설정하는 것이다.


## Reference
* 네트워크 면접 정리 자료 : https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Network
* TCP 3-way handshaking과 4-way handshaking : https://gmlwjd9405.github.io/2018/09/19/tcp-connection.html
* 3-way-handshake & 4-way-handshake : https://asfirstalways.tistory.com/356