# Data Structure(자료구조)

### Array vs LinkedList

**Array**
가장 기본적인 자료구조인 array 자료구조는 논리적인 저장순서와 물리적인 저장순서가 일치한다. 따라서 인덱스로 해당  원소에 접근할 수 있다. 그렇기 때문에 찾고자 하는 원소의 인덱스 값을 알고 있으면 O(1)에 해당원소로 접근할 수 있다. 즉 random access가 가능하다는 장점이 있는 것이다.

하지만 삭제 또는 삽입의 과정에서는 해당 원소에 접근하여 작업을 완료 한뒤(O(1)), 또 한가지의 작업을 추가적으로 해줘야 하기 때문에, 시간이 더 걸린다. 만약 배열의 원소 중 어느 원소를 삭제했다고 했을 때, 배열의 연속적인 특징이 깨지게 된다. 즉, 빈공간이 생기게 되는 것이다. 따라서 삭제한 원소보다 큰 인덱스를 갖는 원소들을 shift 해줘야 하는 비용이 발생하고 이 경우 시간 복잡도는 O(n)가 된다. 그렇기 때문에 Array 자료구조에서 삭제 기능에 대한 time complexity의 worst case는 O(n)이 된다.

삽입의 경우도 마찬가지이다. 만약 첫번째 자리에 새로운 원소를 추가하고자 한다면 모든 원소들의 인덱스를 1 씩 shift 해줘야 하므로 이 경우도 O(n)의 시간을 요구하게 된다.

LinkedList
이 부분에 대한 문제점을 해결하기 위한 자료구조가 연결리스트이다. 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있다. 따라서 이 부분만 다른가뵤으로 바꿔주면 삭제와 삽입을 O(1)만에 해결할 수 있는 것이다.

하지만 LinkedList 역시 한가지 문제가 있다. 원하는 위치에 삽입을 하고자 하면 원하는 위치를 search과정에 있어서 첫번째 원소부터 다 확인해봐야 한다는 것이다. Array와 달리 논리적 저장순서와 물리적 저장순서가 일치하지 않기 때문이다. 이것은 일단 삽입하고 정렬하는 것과 마찬가지이다. 어떠한 원소를 삭제 또는 추가하고자 했을때 그 원소를 찾기위해서 O(n)의 시간이 추가적으로 발생하게 된다.

결국 linked list자료구조는 O(n)time complexity 를 갖고 삽입, 삭제에 대해서도 O(n)의 time complexity를 갖는다,

----------------
### 스택
한쪽 끝에서만 자료를 넣고 뺄 수 있는 LIFO형식의 자료구조
스택의 연산은 가장 최근에 스택에 추가한 항목이 가장 먼저 제거된다.

스택의 활용 사례
* 재귀 알고리즘
* 웹브라우저 방문기록
* 실행 취소
* 역순 문자열 만들기
* 수식의 괄호 검사(연산자우선순위)
* 후위 표기법 계산(postfix)
[스택구현](https://github.com/Dong-wook94/Algorithm-Study/tree/master/%EB%B0%B1%EC%A4%80/%EA%B8%B0%EC%B4%88/%EC%8A%A4%ED%83%9D)

------------------------------
### 큐
먼저 집어 넣은 데이터가 먼저나오는 FIFO구조로 저장하는 방식.

큐의 사용사례 : 데이터가 입력된 시간 순서대로 처리해야 할 필요가 있는 상황에 이용.
* BFS구현
 - 처리해야할 노드의 리스트를 저장하는 용도로 큐를 사용
 - 노드를 하나 처리할때 마다 해당 노드와 인접한 노드들을 큐에 다시 저장한다.
 - 노드를 접근한 순서대로 처리 할 수 있다.
 - 노드를 접근한 순서대로 처리할 수 있다.
* 각종 대기열, 그리고 프로세스 관리에도 많이 쓰임.

[큐 구현](https://github.com/Dong-wook94/Algorithm-Study/tree/master/%EB%B0%B1%EC%A4%80/%EA%B8%B0%EC%B4%88/%EC%8A%A4%ED%83%9D)
-------------
### 트리
노드로 이루어진 자료구조.

1. 하나이상의 루트 노드를 갖는다.
2. 루트노드는 0개이상의 자식노드를 갖고 있다.
3. 그 자식노드 또한 0개이상의 자식노드를 갖고 있고, 이는 반복적으로 정의된다.

트리의 구성요소


