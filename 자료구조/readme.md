# Data Structure(자료구조)

### Array vs LinkedList

**Array**
가장 기본적인 자료구조인 array 자료구조는 논리적인 저장순서와 물리적인 저장순서가 일치한다. 따라서 인덱스로 해당  원소에 접근할 수 있다. 그렇기 때문에 찾고자 하는 원소의 인덱스 값을 알고 있으면 O(1)에 해당원소로 접근할 수 있다. 즉 random access가 가능하다는 장점이 있는 것이다.

하지만 삭제 또는 삽입의 과정에서는 해당 원소에 접근하여 작업을 완료 한뒤(O(1)), 또 한가지의 작업을 추가적으로 해줘야 하기 때문에, 시간이 더 걸린다. 만약 배열의 원소 중 어느 원소를 삭제했다고 했을 때, 배열의 연속적인 특징이 깨지게 된다. 즉, 빈공간이 생기게 되는 것이다. 따라서 삭제한 원소보다 큰 인덱스를 갖는 원소들을 shift 해줘야 하는 비용이 발생하고 이 경우 시간 복잡도는 O(n)가 된다. 그렇기 때문에 Array 자료구조에서 삭제 기능에 대한 time complexity의 worst case는 O(n)이 된다.

삽입의 경우도 마찬가지이다. 만약 첫번째 자리에 새로운 원소를 추가하고자 한다면 모든 원소들의 인덱스를 1 씩 shift 해줘야 하므로 이 경우도 O(n)의 시간을 요구하게 된다.

LinkedList
이 부분에 대한 문제점을 해결하기 위한 자료구조가 연결리스트이다. 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있다. 따라서 이 부분만 다른가뵤으로 바꿔주면 삭제와 삽입을 O(1)만에 해결할 수 있는 것이다.

하지만 LinkedList 역시 한가지 문제가 있다. 원하는 위치에 삽입을 하고자 하면 원하는 위치를 search과정에 있어서 첫번째 원소부터 다 확인해봐야 한다는 것이다. Array와 달리 논리적 저장순서와 물리적 저장순서가 일치하지 않기 때문이다. 이것은 일단 삽입하고 정렬하는 것과 마찬가지이다. 어떠한 원소를 삭제 또는 추가하고자 했을때 그 원소를 찾기위해서 O(n)의 시간이 추가적으로 발생하게 된다.

결국 linked list자료구조는 O(n)time complexity 를 갖고 삽입, 삭제에 대해서도 O(n)의 time complexity를 갖는다,

----------------
### 스택
한쪽 끝에서만 자료를 넣고 뺄 수 있는 LIFO형식의 자료구조
스택의 연산은 가장 최근에 스택에 추가한 항목이 가장 먼저 제거된다.

스택의 활용 사례
* 재귀 알고리즘
* 웹브라우저 방문기록
* 실행 취소
* 역순 문자열 만들기
* 수식의 괄호 검사(연산자우선순위)
* 후위 표기법 계산(postfix)

[스택구현](https://github.com/Dong-wook94/Algorithm-Study/tree/master/%EB%B0%B1%EC%A4%80/%EA%B8%B0%EC%B4%88/%EC%8A%A4%ED%83%9D)

------------------------------
### 큐
먼저 집어 넣은 데이터가 먼저나오는 FIFO구조로 저장하는 방식.

큐의 사용사례 : 데이터가 입력된 시간 순서대로 처리해야 할 필요가 있는 상황에 이용.
* BFS구현
 - 처리해야할 노드의 리스트를 저장하는 용도로 큐를 사용
 - 노드를 하나 처리할때 마다 해당 노드와 인접한 노드들을 큐에 다시 저장한다.
 - 노드를 접근한 순서대로 처리 할 수 있다.
 - 노드를 접근한 순서대로 처리할 수 있다.
* 각종 대기열, 그리고 프로세스 관리에도 많이 쓰임.

[큐 구현](https://github.com/Dong-wook94/Algorithm-Study/tree/master/%EB%B0%B1%EC%A4%80/%EA%B8%B0%EC%B4%88/%EC%8A%A4%ED%83%9D)
-------------
### 트리
노드로 이루어진 자료구조.

1. 하나이상의 루트 노드를 갖는다.
2. 루트노드는 0개이상의 자식노드를 갖고 있다.
3. 그 자식노드 또한 0개이상의 자식노드를 갖고 있고, 이는 반복적으로 정의된다.

트리의 구성요소
* node(노드) : 트리를 구성하고 있는 각각의 요소를 의미한다.
* edge(간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미한다.
* Root Node(루트노드) : 트리구조에서 최상위에 있는 노드를 의미한다.
* Terminal Node(=leaf Node, 단말노드) : 하위에 다른 노드가 연결되어 있지 않은 노드를 의미한다.
* Internal Node(내부노드, 비단말 노드) : 단말노드를 제외한 모든 노드로 루트노드를 포함한다.

-------------------
### Binary Tree(이진트리)
루트노드를 중심으로 두개의 서브트리로 나누어 진다. 또한 나뉘어진 ㅜ 서브트리도 모두 이진 트리어야 한다. degree 가 2인 트리.

트리에서는 각 층별로 숫자를 매겨서 이를 트리의 레벨이라고 한다 레벨의 값은 0부터 시작하고 따라서 루트노드의 레벨은 0이다. 그리고 트리의 최고 레벨을 가리켜 해당 트리의 height(높이)라고 한다.

**Full Binary Tree(포화 이진트리) vs Complete Binary Tree(완전 이진트리)**

모든 레벨이 꽉 찬 이진 트리를 가리켜 포화 이진트리라고 한다. 위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 차곡차곡 채워진 이진 트리를 가리켜 완전 이진트리라고 한다. 배열로 구성된 포화 이진트리와 완전이진 트리는 노드의 개수가 n개일때, i번째 노드에 대해서 parent(i)= i/2, left_child(i) = 2i, right_child(i) = 2i+1 의 index 값을 갖는다.

**BST(Binary search tree)**
효율적인 탐색을 위해서는 어떻게 찾을까만 고민해서는 안된다. 그보다는 효율적인 탐색을 위한 저장방법이 무엇일까를 고민해야되는데 이진탐색 ㅡ리는 이진트리의 일종이다. 단 이진탐색 트리에는 데이터를 저장하는 규칙이있다. 이게 특정 데이터의 위치를 찾는데 사용할 수 있다.
1. 이진탐색 트리의 노드에 저장되는 키는 유일하다.
2. 루트 노드의 키가 왼쪽서브트리를 구성하는 어떠한 노드의 키보다 크다.
3. 루트노드의 키가 오른쪽 서브트리를 구성하는 어떠한 노드의 키보다 작다.
4. 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.

이진탐색 트리의 탐색연산은 O(logn)의 시간복잡도를 갖는다. 최악의 상황은 skewed tree(편향트리) 이때는 저장순서에 따라 한쪽으로만 노드가 추가되는 상황인데 이때가 worst case의 탐색이며 O(n)의 시간 복잡도를 갖게된다. 이 issue를 해결하기 위한 기법이 rebalancing 기법이다.

-------------------------
### Red Black Tree
* 레드블랙 트리가 필요한 이유 : 이진 탐색 트리중에 값이 편향되게 들어 오는 경우가 있다. 그렬경우, 이진 탐색 트리의 검색효율을 나쁘게 하므로, **균형을 바로잡기위해** 레드블랙 트리라는 알고리즘을 사용하도록 한다.

* 레드블랙 트리의 특징
