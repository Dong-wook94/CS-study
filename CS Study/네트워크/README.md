# 네트워크

## HTTP의 GET과 POST 비교
둘 다 Http 프로토콜을 이용해서 서버에 무엇인가를 요청할 때 사용하는 방식이다.
GET, POST 방식의 request는 서버로 본인이 가지고 있는 data를 전달하기 위해서 사용합니다.


### GET
- URL에 변수(데이터)를 포함시켜 요청한다.
- 데이터를 Header(헤더)에 포함하여 전송한다.
- URL에 데이터가 노출되어 보안에 취약하다.
- 전송하는 길이에 제한이 있다.
- 캐싱할 수 있다.(캐싱이란 한번 접근후에 또 요청할시 빠르게 접근하기위해 레지스터에 데이터를 저장시켜 놓는것.)
- GET 방식은 간단한 데이터를 URL에 넣도록 설계된 방식으로 데이터를 보내는 양에 한계가 있습니다.
- URL의 길이가 정해져 있기 때문에 '많은 양의 정보를 전달 할 수 없다'
- URL 형식에 맞지 않는 파라미터 이름이나 값은 인코딩되어 전달해야 합니다. 
- 길이가 너무 길어 생기는 초과데이터는 절단됩니다. 

### POST
- URL에 변수(데이터)를 노출하지 않고 요청한다.
- 데이터를 Body(바디)에 포함시킨다.
- URL에 데이터가 노출되지 않아서 기본 보안은 되어있다.
- 캐싱할 수 없다.
- GET방식은 URL에 데이터를 붙여서 전송하는 반면에 POST방식은 BODY에 데이터를 넣어서 전송합니다. 
- 헤더필드 중 Body의 데이터를 설명하는 Content-Type이라는 헤더 필드가 들어가고 어떠한 데이터 타입인지를 명시해주어야 합니다. 
- 데이터를 Body에 포함시키는 이점 때문에 메시지 길이의 제한이 없다.
- 메시지 길이의 제한은 없지만 최대 요청을 받는 시간인 Time Out이 존재하므로 클라이언트에서 페이지를 요청하고 기다리는 시간이 존재한다.

---------------------------------------------------
## TCP와 UDP의 차이점

TCP/IP에는 TCP와 UDP가 존재하는데 TCP는 신뢰성이 있는 연결을 지향하며. UDP는 빠른 전송을 지향하는 것에서 차이점이 있다. UDP는 일방적인 데이터 전송을 하는 반면, TCP는 데이터 하나라도 놓치지 않고 완벽히 보내는 것이 목표이기 때문에 방향성이 완전 다르다.

그래서 UDP는 알고리즘이 간단한 반면, TCP는 연결부터 끊는 과정까지 상대적으로 복잡하다.

## TCP의 특징
* 인터넷 상에서 데이터를 메세지의 형태(세그먼트라는 블록 단위)로 보내기 위해 IP와 함께 사용하는 프로토콜이다.
    - TCP와 IP를 함께 사용하는데, IP가 데이터의 배달을 처리한다면 TCP는 패킷을 추적 및 관리한다.
* 연결형 서비스로 가상 회선방식을 제공한다.
    - 3-way handshaking 과정을 통해 연결을 설정하고, 4-way handshaking을 통해 연결을 해제한다.
* 흐름제어 및 혼잡제어를 제공한다.
    - 흐름제어 
        - 데이터를 송신하는 곳과 수신하는 곳의 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지하는 것.
        - 송신하는 곳에서 감당이 안되게 많은 데이터를 빠르게 보내 수신하는 곳에서 문제가 일어나는 것을 막는다.
    - 혼잡제어
        - 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것.
        - 정보의 소통량이 과다하면 패킷을 조금만 전송하여 혼잡 붕괴현상이 일어나는 것을 막는다.
* 높은 신뢰성을 보장한다.
* UDP보다 속도가 느리다.
* 전송이 양방향으로 동시에 일어날 수 있다.
* 각 연결이 정확히 2개의 종단점을 가지고 있다.
* 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다.
* 연속성보다 신뢰성있는 전송이 중요할 때에 사용된다.

## TCP의 3-way handshake
TCP 통신을 이용하여 데이터를 전송하기위해 네트워크 '연결을 설정하는 과정'
* 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달이 시작하기 전에 한 쪽이 다른 쪽이 준비되었다는 것을 알 수 있도록 한다.
    - 즉, TCP/IP 프로토콜을 이용해서 통신을 하는 응용 프로그램이 데이터를 전송하기전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.

과정
![image](https://user-images.githubusercontent.com/36303777/66185799-7d7b0d80-e6bb-11e9-8738-e6f8f23c48c9.png)
1) 클라이언트는 서버에 접속을 요청하는 SYN(a) 패킷을 보낸다.
2) 서버는 클라이언트의 요청인 SYN(a)를 받고 클라이언트에게 요청을 수락한다는 ACK(a+1)와 SYN(b)이 설정된 패킷을 발송한다.
3) 클라이언트는 서버의 수락 응답인 ACK(a+1)와 SYN(b) 패킷을 받고 ACK(b+1)를 서버로 보내면 연결이 성립된다.
## TCP의 4-way handshake
TCP의 '연결을 해제하는 과정'
![image](https://user-images.githubusercontent.com/36303777/66186068-3ccfc400-e6bc-11e9-87b5-45c87c271f76.png)
1) 클라이언 트가 연결을 종료하겠다는 **FIN플래그**를 전송한다.
2) 서버는 클라이언트의 요청(**FIN**)을 받고 확인 메시지로 **ACK**를 보낸다. 그리고나서는 데이터를 모두 보낼 때 가지 잠깐 **TIME_OUT** 된다.
3) 데이터를 모두 보내고 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 **FIN** 플래그를 전송한다.
4) 클라이언트는 **FIN메시지**를 확인했다는 **메시지(ACK)**를 보낸다.
5) 클라이언트의 **ACK 메시지**를 받은 서버는 소켓 **연결을 close** 한다.
6) 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을것을 대비해 일정 시간 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거친다.(**TIME_WAIT**)

## SYN Packet & ACK Packet
* SYN : synchronize sequence number
* ACK : acknowledgement

TCP Header에는 Code Bit(Flag bit)라는 부분이 존재한다. 이 부분은 6bit로 이루어져 있으며 각각 한 bit들이 의미를 갖고 있다. Urg-Ack-Psh-Rst-Syn-Fin 순서로 되어있으며 해당 위치의 비트가 1이면 해당 패킷이 어떠한 내용을 담고 있는 패킷인지를 나타낸다. SYN 패킷일 경우엘 000010이 되고 ACK패킷일 경우에는 010000이 되는것이다.

## randomized sequence number 사용이유
처음 클라이언트에서 SYN패킷을 보낼대 Sequence Number에는 랜덤한 숫자가 담겨진다. 초기 Sequence number를 ISN이라고한다. ISN이 0부터 시작하지않고 난수를 생성해서 number를 설정하는 이유는 Connection을 맺을때 사용하는 포트는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용된다. 따라서 두 통신 호스타가 과거에 사용된 포트번호 쌍을 사용하는 가능성이 존재한다. 서버 측에서는 패킷의 SYN을 보고 패킷을 구분하게 되는데 난수가 아닌 순차적인 number가 전송된다면 이전의 connection으로부터 오는 패킷으로 인식할 수 있다. 이러한 문제가 발생할 가능성을 줄이기 위해서 난수로 ISN을 설정하는 것이다.

--------------------------------------------------

## Nagle 알고리즘

> 네트워크 상에 패킷의 수를 줄이기 위해 개발된 알고리즘.

1. 일반 네트워크 통신방법

   - 일반적인 통신 알고리즘은 데이터는 패킷으로 만드렁 보낸다는 것이며 수신호스트는 이에 대한 ACK를 보낸다는 것입니다. A,B 두호스트가 통신을 할 때, A는 B에게 'Nagle'이라는 데이터를 보내기 원하면, 먼저 'N'이라는 데이터를 패킷으로 만들어 출력버퍼로 보냅니다. 그리고 ACK를 받고 안받고 관계없이 'a'를 패킷으로 만들어 보내고 이어서 'g','l','e' 각 데이터를 패킷으로 만들어 보낼 것입니다. 수신호스트로부터 ACK가 언제오는가는 전혀 관계가 없고, 언제 오든지 오기만 하면 되는 것 입니다.

2. Nagle 알고리즘

   - 네트웍에서 Nagle알고리즘은 `"가능하면 조금씩 여러 번 보내지 말고 한번에 많이보내라(Effective TCP)"` 라는 원칙을 기반으로 만들어진 알고리즘 입니다.
   - Nagle 알고리즘의 원리는 ACK를 받은 다음에 데이터를 보내고 ACK를 받을 때 까지 출력버퍼의 데이터를 저장하였다가 ACK를 받으면 버퍼의 데이터를 모두 패킷으로 만들어 보낸다는 것입니다. 예를 들어 A가 'N'이라는 데이터를 패킷으로 만들어 보내고, 계속해서 다음 데이터를 보내는 것이 아니라 출력버퍼로 보내어 저장시켜 둡니다. 그러다가 ACK가 오면 출력버퍼에 저장된 'agle'라는 데이터를 보냅니다.

   ![image](https://user-images.githubusercontent.com/36303777/66248948-19625300-e768-11e9-878e-8cf43adbe97f.png)

### Nagle 알고리즘의 장단점

- 장점 : `네트워크 효율성이 높아짐`. (똑같은 데이터를 보내더라도 생산하는 패킷이 적음)
- 단점 : 송신 호스트가 ACK를 받을 때까지 기다려야 하므로 `전송 속도가 느려짐`.



### Nagle 알고리즘의 중단

네트워크의 전송량이나 부하보다는 빠른 응답속도를 더 중요시 하는상황에는 TCP_NODELAY 옵션을 1(True)로 변경하여 Nagle알고리즘을 적용하지 않을수 있습니다.(적용하려면 2(False))

---------------------------------------

## 서브넷 마스크

### 서브네팅(Subnetting)이란?

> 네트워크 관리자가 네트워크 성능을 향상 시키기 위해, 자원을 효율적으로 분배하는 것. 여기서 자원을 효율적으로 분배한다는것은 네트워크 영역과 호스트 영역을 분할하는 것.

너무큰 브로드캐스트 도메인은 네트워크 환경에서 패킷 전송을 느리게하고 성능저하를 발생시킵니다. 따라서 네트워크를 쪼개서 통신 성능을 보장하는 것입니다. IP주소는 32자리 2진수로 표현하기때문에 제한된 자원을 낭비없이 쓰는게 필수적입니다.

그래서 등장하는것이 **서브넷마스크**입니다. 

서브넷 마스크는 필요한 네트워크 주소만 호스트IP로 할당 할 수 있게 만들어 네트워크 낭비를 방지합니다. 

### 서브넷마스크 표시방법

서브넷 마스크는 기본적으로 1과 0으로 구성되어 있으며, 1이 연속으로 나와야 합니다. 

~~~
ex) 11101 -> 안됨
	10011 -> 안됨
	1111000 -> 이런식으로 1이 연속으로 나와야됨.
~~~

IP 주소에서 만약 192.168.0.1/24라고하면 이는 C클래스이고 기본 디폴트 마스크는 255.255.255.0 입니다. 디폴트 마스크도 서브넷마스크입니다.

255.255.255.0  == 1111 1111.1111 1111.1111 1111.0000 0000 입니다.

IP 뒤에 /24라는 표현이 1이 24개 있다는 뜻입니다.

1은 네트워크 영역으로 사용하겠다는 뜻이고 0은 호스트 IP로 사용하겠다는 뜻입니다.

----------------------------

## OSI 7계층

> 일단 간단히 정리후 추후 자세히 정리할 예정

### 7계층 - 응용계층(Application)

OSI 7계층 중 최상위 계층이며, 사용자가 직접 눈으로 보고 실제로 작업을 하는 계층이다. `웹브라우저, HTTP, FTP, WWW, Telnet, SMTP, POP` 등의 사용자와 직접적으로 상호작용 하는 모든 `응용프로그램`들이 속한다.







### 6계층 - 표현계층(Presentation)

표현계층은 data의 foramt을 정의한다. 일반적으로 응용프로그램형식을 준비 또는 네트워크 형식으로 변환하거나 네트워크 형식을 응용프로그램 형식으로 변환하는 것을 나타낸다. 

서로다른 환경의 컴퓨터와 Application들이 data를 서로 이해 할수있게 도와주는 계층.

### 5계층 - 세션 계층(Session)

통신의 일을 책임지고 있는 계층이다. 2대의 기기, 컴퓨터 또는 서버간에 통신을 하기 위해서는 세션을 만들어야 하는데 이 작업이 여기서 처리된다.

네트워크 연결을 성립, 제어와 운영, 연결의 종료를 책임진다. 또 각각의 알맞은 Application으로 Data를 보내기 위해서는 Applicaiton으로부터 들어오는 Data들을 분리해서 유지해주는 기능을 수행한다. OS가 이 계층에 속한다.

### 4계층 - 전송계층(Transport)

전송 계층은 Data의 전송을 담당한다. 보낼 데이터의 용량과 속도, 목적지등을 처리한다. 대표적으로 TCP와 UDP가 있다. 기기의 IP 주소가 여기서 작동한다. Data가 잘 전송되고 있는지 확인하고 만약 중간에 에러가 발생하면 이를 알아내서 다시 에러난 부분을 재전송해준다. (TCP의 경우에만)

### 3계층 - 네트워크 계층(Network)

네트워크 계층의 가장 중요한 일은 패킷을 목적지까지 가장 빠른 길로 전송하는 역할. 이계층에서 사용되는 장비로 Router가 있다. 여기서는 에러처리를 하지않는다(상위계층에서 해결해주기 때문에). 이 네트워크 계층에서 사용되는 프로토콜로는 IP,IPX,ICMP,ARP 등이 있다.

### 2계층 - 데이터 링크 계층(Data Link)

데이터의 물리적인 전송(직접 연결된 노드간)을 담당하고, Error Notification, Flow Control등을 다룬다. 데이터 전송시 에러가 발생하면 데이터 링크계층에서 검출을하고 전송계층에서 그 에러를 수정한다. 데이터링크 계층에서 사용되는 장비로는 Bridge, Switch가 있다.

### 1계층 - 물리계층(Physical)

물리 계층은 Data를 전기신호로 바꿔주는 역할을 한다. 케이블 종류, 무선주파수, 핀배치, 전압, 물리 요건등이 포함된다. 

-----

## REST 와 REST API

### REST의 정의

* "Representational State Transfer"의 약자
  * 자원을 이름으로 구분하여 해당 자원의 상태를 주고 받는 모든것.
  * 자원(resource)의 표현(representation)에 의한 상태전달.
  * JSON 혹은 XML을 통해 데이터를 주고 받는 것이 일반적이다.
  * 데이터가 요청되어지는 시점에서 자원의 상태(정보)를 전달한다.
* 월드 와이드 웹(www)과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 개발 아키텍처의 한 형식
  * REST는 기본적으로 웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하기 때문에 **웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일**이다.
  * REST는 네트워크 상에서 Client와 Server 사이의 통신방식 중 하나이다.
* REST의 구체적인 개념.
  * HTTP URI(Uniform Resource Identifier)를통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미한다. 
    * CRUD Operation 
      * Create : 생성(POST)
      * Read : 조회(GET)
      * Update : 수정(PUT)
      * Delete : 삭제(DELETE)
      * HEAD : header 정보 조회 (HEAD)



####  REST의 장단점 

* 장점 
  * HTTP 프로토콜의 인프라를 그대로 사용하므로 REST API 사용을 위한 별도의 인프라를 구축할 필요가 없다.
  * HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용이 가능하다.
  * Hypermedia API 의 기본을 충실히 지키면서 범용성을 보장한다.
  * REST API 메시지가 의도하는 바를 명확하게 나타내므로 의도하는 바를 쉽게 파악할 수 있다.
  * 서버와 클라이언트의 역할을 명확하게 분리한다.
* 단점
  * 표준이 존재하지 않는다.
  * 사용할 수 있는 메소드가 4가지 밖에없다.
    * HTTP Method 형태가 제한적이다.
  * 구형 브라우저가 아직 제대로 지원해주지 목하는 부분이 존재한다.
    * PUT, DELETE를 사용하지 못하는점.
    * pushState를 지원하지 않는 점.



#### REST의 특징

1. Server-Client(서버 클라이언트 구조)
   * 자원이 있는 쪽이 Server, 자원을 요청하는 쪽이 Client가 된다.
     * REST Server : API를 제공하고 비즈니스 로직 처리 및 저장을 책임진다.
     * Client : 사용자 인증이나 context(세션, 로그인 정보)등을 직접 관리하고 책임진다. 
   * 서로 간 의존성이 줄어든다.
2. Stateless(무상태)
   * HTTP 프로토콜은 Stateless Protocol이므로 REST 역시 무상태성을 갖는다.
   * Client의 context를 Server에 저장하지 않는다.
     * 즉, 세션과 쿠키와 같은 context 정보를 신경쓰지 않아도 되므로 구현이 단순해진다.
   * Server는 각각의 요청을 완전히 별개의 것으로 인식하고 처리한다.
     * 각 API 서버는 Client의 요청만을 단순 처리한다.
     * 즉, 이전 요청이 다음 요청의 처리에 연관되어서는 안된다.
     * 물론 이전 요청이 DB를 수정하여 DB에 의해 바뀌는 것은 허용한다.
     * Server의 처리방식에 일관성을 부여하고 부담이 줄어들며, 서비스의 자유도가 높아진다.
3. Cacheable(캐시 처리 가능)
   * 웹 표준 HTTP프로토콜을 그대로 사용하므로 웹에서 사용하는 기존의 인프라를 그대로 활용할 수 있다.
     * 즉, HTTP가 가진 가장 강력한 특징 중 하나인 캐싱 기능을 적용할 수 있다.
     * HTTP 프로토콜 표준에서 사용하는 Last-Modified 태그나 E-Tag를 이용하면 캐싱 구현이 가능하다.
   * 대량의 요청을 효율적으로 처리하기 위해 캐시가 요구된다.
   * 캐시사용을 통해 응답시간이 빨라지고 REST Server트랜잭션이 발생하지 않기 때문에 전체 응답시간, 성능, 서버의 자원 이용률을 향상시킬 수 있다
4. Layered System(계층화)
5. Code-On-Demand(optional)
   * 서버로부터 스크립트를 받아서 Client에서 실행한다.
   * 반드시 충족할 필요는 없다.
6. Uniform Interface(인터페이스 일관성)

   * URI로 지정한 Resource에 대한 조작을 통일되고 한정적인 인터페이스로 수행한다.
   * HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용이 가능하다.
     * 특정 언어나 기술에 종속되지 않는다.



### REST API의 개념

#### REST API란 

* API (Application Programming Interface)란
  * 데이터와 기능의 집합을 제공하여 컴퓨터 프로그램간 상호작용을 촉진하며, 서로 정보를 교환가능 하도록 하는것.
* REST API의 정의
  * REST 기반으로 서비스 API를 구현한 것.
  * 최근 OpenAPI, 마이크로 서비스(하나의 큰 애플리케이션을 여러개의 작은 애플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처)등을 제공하는 업체 대부분은 REST API를 제공한다.

-------------------------

## Reference

* 네트워크 면접 정리 자료 : https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Network
* TCP 3-way handshaking과 4-way handshaking : https://gmlwjd9405.github.io/2018/09/19/tcp-connection.html
* 3-way-handshake & 4-way-handshake : https://asfirstalways.tistory.com/356
* Nagle 알고리즘 : http://egloos.zum.com/depiness/v/772710
* 서브넷 마스크 : https://limkydev.tistory.com/166
* OSI 7계층 : https://jw3461.tistory.com/4
* REST : https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html